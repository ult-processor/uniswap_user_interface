"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _path = _interopRequireDefault(require("path"));

var R = _interopRequireWildcard(require("ramda"));

var _conf = require("@lingui/conf");

var _api = require("@lingui/cli/api");

var _loaderUtils = _interopRequireDefault(require("loader-utils"));

// Check if webpack 5
var isWebpack5 = parseInt(require("webpack").version) === 5; // Check if JavascriptParser and JavascriptGenerator exists -> Webpack 4

var JavascriptParser;
var JavascriptGenerator;

try {
  JavascriptParser = require("webpack/lib/Parser");
  JavascriptGenerator = require("webpack/lib/JavascriptGenerator");
} catch (error) {
  if (error.code !== "MODULE_NOT_FOUND") {
    throw e;
  }
}

var requiredType = "javascript/auto";

function _default(source) {
  var options = _loaderUtils.default.getOptions(this) || {};

  if (!isWebpack5 && JavascriptParser && JavascriptGenerator) {
    // Webpack 4 uses json-loader automatically, which breaks this loader because it
    // doesn't return JSON, but JS module. This is a temporary workaround before
    // official API is added (https://github.com/webpack/webpack/issues/7057#issuecomment-381883220)
    // See https://github.com/webpack/webpack/issues/7057
    this._module.type = requiredType;
    this._module.parser = new JavascriptParser();
    this._module.generator = new JavascriptGenerator();
  }

  var config = (0, _conf.getConfig)({
    configPath: options.config,
    cwd: _path.default.dirname(this.resourcePath)
  });
  var EMPTY_EXT = /\.[0-9a-z]+$/.test(this.resourcePath);
  var JS_EXT = /\.js+$/.test(this.resourcePath);

  var catalogRelativePath = _path.default.relative(config.rootDir, this.resourcePath);

  if (!EMPTY_EXT || JS_EXT) {
    var formats = {
      minimal: ".json",
      po: ".po",
      lingui: ".json"
    }; // we replace the .js, because webpack appends automatically the .js on imports without extension

    throw new Error("File extension is mandatory, for ex: import(\"@lingui/loader!./".concat(catalogRelativePath.replace(".js", formats[config.format]), "\")"));
  }

  var _getCatalogForFile = (0, _api.getCatalogForFile)(catalogRelativePath, (0, _api.getCatalogs)(config)),
      locale = _getCatalogForFile.locale,
      catalog = _getCatalogForFile.catalog;

  var catalogs = catalog.readAll();
  var messages = R.mapObjIndexed(function (_, key) {
    return catalog.getTranslation(catalogs, locale, key, {
      fallbackLocales: config.fallbackLocales,
      sourceLocale: config.sourceLocale
    });
  }, catalogs[locale]); // In production we don't want untranslated strings. It's better to use message
  // keys as a last resort.
  // In development, however, we want to catch missing strings with `missing` parameter
  // of I18nProvider (React) or setupI18n (core) and therefore we need to get
  // empty translations if missing.

  var strict = process.env.NODE_ENV !== "production";
  return (0, _api.createCompiledCatalog)(locale, messages, {
    strict: strict,
    namespace: config.compileNamespace,
    pseudoLocale: config.pseudoLocale
  });
}